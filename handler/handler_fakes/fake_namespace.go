// This file was generated by counterfeiter
package handler_fakes

import (
	"sync"

	"k8s.io/kubernetes/pkg/api"
	v1api "k8s.io/kubernetes/pkg/api/v1"
	"k8s.io/kubernetes/pkg/client/clientset_generated/release_1_3/typed/core/v1"
	"k8s.io/kubernetes/pkg/watch"
)

type FakeNamespace struct {
	CreateStub        func(*v1api.Namespace) (*v1api.Namespace, error)
	createMutex       sync.RWMutex
	createArgsForCall []struct {
		arg1 *v1api.Namespace
	}
	createReturns struct {
		result1 *v1api.Namespace
		result2 error
	}
	UpdateStub        func(*v1api.Namespace) (*v1api.Namespace, error)
	updateMutex       sync.RWMutex
	updateArgsForCall []struct {
		arg1 *v1api.Namespace
	}
	updateReturns struct {
		result1 *v1api.Namespace
		result2 error
	}
	UpdateStatusStub        func(*v1api.Namespace) (*v1api.Namespace, error)
	updateStatusMutex       sync.RWMutex
	updateStatusArgsForCall []struct {
		arg1 *v1api.Namespace
	}
	updateStatusReturns struct {
		result1 *v1api.Namespace
		result2 error
	}
	DeleteStub        func(name string, options *api.DeleteOptions) error
	deleteMutex       sync.RWMutex
	deleteArgsForCall []struct {
		name    string
		options *api.DeleteOptions
	}
	deleteReturns struct {
		result1 error
	}
	DeleteCollectionStub        func(options *api.DeleteOptions, listOptions api.ListOptions) error
	deleteCollectionMutex       sync.RWMutex
	deleteCollectionArgsForCall []struct {
		options     *api.DeleteOptions
		listOptions api.ListOptions
	}
	deleteCollectionReturns struct {
		result1 error
	}
	GetStub        func(name string) (*v1api.Namespace, error)
	getMutex       sync.RWMutex
	getArgsForCall []struct {
		name string
	}
	getReturns struct {
		result1 *v1api.Namespace
		result2 error
	}
	ListStub        func(opts api.ListOptions) (*v1api.NamespaceList, error)
	listMutex       sync.RWMutex
	listArgsForCall []struct {
		opts api.ListOptions
	}
	listReturns struct {
		result1 *v1api.NamespaceList
		result2 error
	}
	WatchStub        func(opts api.ListOptions) (watch.Interface, error)
	watchMutex       sync.RWMutex
	watchArgsForCall []struct {
		opts api.ListOptions
	}
	watchReturns struct {
		result1 watch.Interface
		result2 error
	}
	FinalizeStub        func(item *v1api.Namespace) (*v1api.Namespace, error)
	finalizeMutex       sync.RWMutex
	finalizeArgsForCall []struct {
		item *v1api.Namespace
	}
	finalizeReturns struct {
		result1 *v1api.Namespace
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeNamespace) Create(arg1 *v1api.Namespace) (*v1api.Namespace, error) {
	fake.createMutex.Lock()
	fake.createArgsForCall = append(fake.createArgsForCall, struct {
		arg1 *v1api.Namespace
	}{arg1})
	fake.recordInvocation("Create", []interface{}{arg1})
	fake.createMutex.Unlock()
	if fake.CreateStub != nil {
		return fake.CreateStub(arg1)
	} else {
		return fake.createReturns.result1, fake.createReturns.result2
	}
}

func (fake *FakeNamespace) CreateCallCount() int {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	return len(fake.createArgsForCall)
}

func (fake *FakeNamespace) CreateArgsForCall(i int) *v1api.Namespace {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	return fake.createArgsForCall[i].arg1
}

func (fake *FakeNamespace) CreateReturns(result1 *v1api.Namespace, result2 error) {
	fake.CreateStub = nil
	fake.createReturns = struct {
		result1 *v1api.Namespace
		result2 error
	}{result1, result2}
}

func (fake *FakeNamespace) Update(arg1 *v1api.Namespace) (*v1api.Namespace, error) {
	fake.updateMutex.Lock()
	fake.updateArgsForCall = append(fake.updateArgsForCall, struct {
		arg1 *v1api.Namespace
	}{arg1})
	fake.recordInvocation("Update", []interface{}{arg1})
	fake.updateMutex.Unlock()
	if fake.UpdateStub != nil {
		return fake.UpdateStub(arg1)
	} else {
		return fake.updateReturns.result1, fake.updateReturns.result2
	}
}

func (fake *FakeNamespace) UpdateCallCount() int {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	return len(fake.updateArgsForCall)
}

func (fake *FakeNamespace) UpdateArgsForCall(i int) *v1api.Namespace {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	return fake.updateArgsForCall[i].arg1
}

func (fake *FakeNamespace) UpdateReturns(result1 *v1api.Namespace, result2 error) {
	fake.UpdateStub = nil
	fake.updateReturns = struct {
		result1 *v1api.Namespace
		result2 error
	}{result1, result2}
}

func (fake *FakeNamespace) UpdateStatus(arg1 *v1api.Namespace) (*v1api.Namespace, error) {
	fake.updateStatusMutex.Lock()
	fake.updateStatusArgsForCall = append(fake.updateStatusArgsForCall, struct {
		arg1 *v1api.Namespace
	}{arg1})
	fake.recordInvocation("UpdateStatus", []interface{}{arg1})
	fake.updateStatusMutex.Unlock()
	if fake.UpdateStatusStub != nil {
		return fake.UpdateStatusStub(arg1)
	} else {
		return fake.updateStatusReturns.result1, fake.updateStatusReturns.result2
	}
}

func (fake *FakeNamespace) UpdateStatusCallCount() int {
	fake.updateStatusMutex.RLock()
	defer fake.updateStatusMutex.RUnlock()
	return len(fake.updateStatusArgsForCall)
}

func (fake *FakeNamespace) UpdateStatusArgsForCall(i int) *v1api.Namespace {
	fake.updateStatusMutex.RLock()
	defer fake.updateStatusMutex.RUnlock()
	return fake.updateStatusArgsForCall[i].arg1
}

func (fake *FakeNamespace) UpdateStatusReturns(result1 *v1api.Namespace, result2 error) {
	fake.UpdateStatusStub = nil
	fake.updateStatusReturns = struct {
		result1 *v1api.Namespace
		result2 error
	}{result1, result2}
}

func (fake *FakeNamespace) Delete(name string, options *api.DeleteOptions) error {
	fake.deleteMutex.Lock()
	fake.deleteArgsForCall = append(fake.deleteArgsForCall, struct {
		name    string
		options *api.DeleteOptions
	}{name, options})
	fake.recordInvocation("Delete", []interface{}{name, options})
	fake.deleteMutex.Unlock()
	if fake.DeleteStub != nil {
		return fake.DeleteStub(name, options)
	} else {
		return fake.deleteReturns.result1
	}
}

func (fake *FakeNamespace) DeleteCallCount() int {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return len(fake.deleteArgsForCall)
}

func (fake *FakeNamespace) DeleteArgsForCall(i int) (string, *api.DeleteOptions) {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return fake.deleteArgsForCall[i].name, fake.deleteArgsForCall[i].options
}

func (fake *FakeNamespace) DeleteReturns(result1 error) {
	fake.DeleteStub = nil
	fake.deleteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeNamespace) DeleteCollection(options *api.DeleteOptions, listOptions api.ListOptions) error {
	fake.deleteCollectionMutex.Lock()
	fake.deleteCollectionArgsForCall = append(fake.deleteCollectionArgsForCall, struct {
		options     *api.DeleteOptions
		listOptions api.ListOptions
	}{options, listOptions})
	fake.recordInvocation("DeleteCollection", []interface{}{options, listOptions})
	fake.deleteCollectionMutex.Unlock()
	if fake.DeleteCollectionStub != nil {
		return fake.DeleteCollectionStub(options, listOptions)
	} else {
		return fake.deleteCollectionReturns.result1
	}
}

func (fake *FakeNamespace) DeleteCollectionCallCount() int {
	fake.deleteCollectionMutex.RLock()
	defer fake.deleteCollectionMutex.RUnlock()
	return len(fake.deleteCollectionArgsForCall)
}

func (fake *FakeNamespace) DeleteCollectionArgsForCall(i int) (*api.DeleteOptions, api.ListOptions) {
	fake.deleteCollectionMutex.RLock()
	defer fake.deleteCollectionMutex.RUnlock()
	return fake.deleteCollectionArgsForCall[i].options, fake.deleteCollectionArgsForCall[i].listOptions
}

func (fake *FakeNamespace) DeleteCollectionReturns(result1 error) {
	fake.DeleteCollectionStub = nil
	fake.deleteCollectionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeNamespace) Get(name string) (*v1api.Namespace, error) {
	fake.getMutex.Lock()
	fake.getArgsForCall = append(fake.getArgsForCall, struct {
		name string
	}{name})
	fake.recordInvocation("Get", []interface{}{name})
	fake.getMutex.Unlock()
	if fake.GetStub != nil {
		return fake.GetStub(name)
	} else {
		return fake.getReturns.result1, fake.getReturns.result2
	}
}

func (fake *FakeNamespace) GetCallCount() int {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	return len(fake.getArgsForCall)
}

func (fake *FakeNamespace) GetArgsForCall(i int) string {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	return fake.getArgsForCall[i].name
}

func (fake *FakeNamespace) GetReturns(result1 *v1api.Namespace, result2 error) {
	fake.GetStub = nil
	fake.getReturns = struct {
		result1 *v1api.Namespace
		result2 error
	}{result1, result2}
}

func (fake *FakeNamespace) List(opts api.ListOptions) (*v1api.NamespaceList, error) {
	fake.listMutex.Lock()
	fake.listArgsForCall = append(fake.listArgsForCall, struct {
		opts api.ListOptions
	}{opts})
	fake.recordInvocation("List", []interface{}{opts})
	fake.listMutex.Unlock()
	if fake.ListStub != nil {
		return fake.ListStub(opts)
	} else {
		return fake.listReturns.result1, fake.listReturns.result2
	}
}

func (fake *FakeNamespace) ListCallCount() int {
	fake.listMutex.RLock()
	defer fake.listMutex.RUnlock()
	return len(fake.listArgsForCall)
}

func (fake *FakeNamespace) ListArgsForCall(i int) api.ListOptions {
	fake.listMutex.RLock()
	defer fake.listMutex.RUnlock()
	return fake.listArgsForCall[i].opts
}

func (fake *FakeNamespace) ListReturns(result1 *v1api.NamespaceList, result2 error) {
	fake.ListStub = nil
	fake.listReturns = struct {
		result1 *v1api.NamespaceList
		result2 error
	}{result1, result2}
}

func (fake *FakeNamespace) Watch(opts api.ListOptions) (watch.Interface, error) {
	fake.watchMutex.Lock()
	fake.watchArgsForCall = append(fake.watchArgsForCall, struct {
		opts api.ListOptions
	}{opts})
	fake.recordInvocation("Watch", []interface{}{opts})
	fake.watchMutex.Unlock()
	if fake.WatchStub != nil {
		return fake.WatchStub(opts)
	} else {
		return fake.watchReturns.result1, fake.watchReturns.result2
	}
}

func (fake *FakeNamespace) WatchCallCount() int {
	fake.watchMutex.RLock()
	defer fake.watchMutex.RUnlock()
	return len(fake.watchArgsForCall)
}

func (fake *FakeNamespace) WatchArgsForCall(i int) api.ListOptions {
	fake.watchMutex.RLock()
	defer fake.watchMutex.RUnlock()
	return fake.watchArgsForCall[i].opts
}

func (fake *FakeNamespace) WatchReturns(result1 watch.Interface, result2 error) {
	fake.WatchStub = nil
	fake.watchReturns = struct {
		result1 watch.Interface
		result2 error
	}{result1, result2}
}

func (fake *FakeNamespace) Finalize(item *v1api.Namespace) (*v1api.Namespace, error) {
	fake.finalizeMutex.Lock()
	fake.finalizeArgsForCall = append(fake.finalizeArgsForCall, struct {
		item *v1api.Namespace
	}{item})
	fake.recordInvocation("Finalize", []interface{}{item})
	fake.finalizeMutex.Unlock()
	if fake.FinalizeStub != nil {
		return fake.FinalizeStub(item)
	} else {
		return fake.finalizeReturns.result1, fake.finalizeReturns.result2
	}
}

func (fake *FakeNamespace) FinalizeCallCount() int {
	fake.finalizeMutex.RLock()
	defer fake.finalizeMutex.RUnlock()
	return len(fake.finalizeArgsForCall)
}

func (fake *FakeNamespace) FinalizeArgsForCall(i int) *v1api.Namespace {
	fake.finalizeMutex.RLock()
	defer fake.finalizeMutex.RUnlock()
	return fake.finalizeArgsForCall[i].item
}

func (fake *FakeNamespace) FinalizeReturns(result1 *v1api.Namespace, result2 error) {
	fake.FinalizeStub = nil
	fake.finalizeReturns = struct {
		result1 *v1api.Namespace
		result2 error
	}{result1, result2}
}

func (fake *FakeNamespace) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	fake.updateStatusMutex.RLock()
	defer fake.updateStatusMutex.RUnlock()
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	fake.deleteCollectionMutex.RLock()
	defer fake.deleteCollectionMutex.RUnlock()
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	fake.listMutex.RLock()
	defer fake.listMutex.RUnlock()
	fake.watchMutex.RLock()
	defer fake.watchMutex.RUnlock()
	fake.finalizeMutex.RLock()
	defer fake.finalizeMutex.RUnlock()
	return fake.invocations
}

func (fake *FakeNamespace) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ v1.NamespaceInterface = new(FakeNamespace)
